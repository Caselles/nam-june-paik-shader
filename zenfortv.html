<canvas id="c"></canvas>
<script type="module">
    const gl = c.getContext("webgl2");
    c.width = innerWidth; c.height = innerHeight;
    gl.viewport(0, 0, c.width, c.height);
    const vs = `#version 300 es
in vec2 a_pos;out vec2 uv;
void main(){uv=(a_pos+1.0)*0.5;gl_Position=vec4(a_pos,0.0,1.0);}
`;
    const fs = `#version 300 es

precision highp float;

uniform vec2 u_resolution;
uniform float u_time;

in vec2 uv;
out vec4 out_color;

// Hash function to create pseudo-randomness based on time
float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

// Interpolated noise
float noise(float x) {
    float i = floor(x);
    float f = fract(x);
    float u = f * f * (3.0 - 2.0 * f); // smoothstep
    return mix(hash(i), hash(i + 1.0), u);
}

void main() {
    vec2 fragCoord = uv * u_resolution;
    vec2 pos = fragCoord / u_resolution;
    pos = pos * 2.0 - 1.0;  // Center UVs from -1 to 1

    // Irregular pulse using noise
    float pulse = 0.01 * (noise(u_time * 0.5) - 0.5);
    float intensity = 0.5 + pulse;

    float y = abs(pos.y); // vertical distance from center line

    float glowFalloff = 0.02 + 0.001 * sin(u_time * 3.0);
    glowFalloff = max(glowFalloff, 0.001); // avoid divide-by-zero

    float g = pow(y / glowFalloff, 0.2);

    vec3 bg = vec3(60.0 / 255.0);
    vec3 glow = vec3(1.6, 1.7, 1.82);
    glow = glow * -g * intensity + glow;
    glow = glow * glow;
    glow = glow * glow;

    vec3 col = bg + glow;

    out_color = vec4(col, 1.0);
}`;
    function compile(type, src) {
        const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
        return s;
    }
    const prog = gl.createProgram();
    gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
    gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(prog); gl.useProgram(prog);
    const b = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, b);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
    const loc = gl.getAttribLocation(prog, "a_pos");
    gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
    const ures = gl.getUniformLocation(prog, "u_resolution");
    const utime = gl.getUniformLocation(prog, "u_time");
    function draw(t) {
        gl.uniform2f(ures, c.width, c.height);
        gl.uniform1f(utime, t * 0.001);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
</script>
<style>
    body,
    html {
        margin: 0;
        overflow: hidden;
        background: black
    }

    canvas {
        width: 100vw;
        height: 100vh;
        display: block
    }
</style>